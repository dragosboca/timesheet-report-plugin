#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const peggy = require('peggy');

const grammarPath = path.join(__dirname, '../src/query/grammar.pegjs');
const outputPath = path.join(__dirname, '../src/query/generated-parser.ts');

// Read the grammar file
const grammar = fs.readFileSync(grammarPath, 'utf8');

// Generate the parser
const parser = peggy.generate(grammar, {
  output: 'source',
  format: 'es',
  trace: false
});

// Add TypeScript suppression for generated code
const parserWithSuppressions = `/* eslint-disable */
// @ts-nocheck
${parser}`;

// Wrap the generated parser in TypeScript module format
const tsContent = `// Auto-generated parser from grammar.pegjs
// Do not edit this file directly - edit grammar.pegjs instead

import {
  QueryNode,
  ClauseNode,
  WhereClauseNode,
  ShowClauseNode,
  ViewClauseNode,
  ChartClauseNode,
  PeriodClauseNode,
  SizeClauseNode,
  BinaryExpressionNode,
  ExpressionNode,
  LiteralNode,
  IdentifierNode,
  DateRangeNode,
  ListNode
} from './ast';

export class ParseError extends Error {
  public location?: {
    start: { line: number; column: number };
    end: { line: number; column: number };
  };

  constructor(message: string, location?: any) {
    super(message);
    this.name = 'ParseError';
    this.location = location;
  }
}

// Generated parser code
${parserWithSuppressions}

export function parse(input: string): QueryNode {
  try {
    return peg$parse(input);
  } catch (error: any) {
    if (error.location) {
      throw new ParseError(
        \`Parse error at line \${error.location.start.line}, column \${error.location.start.column}: \${error.message}\`,
        error.location
      );
    }
    throw new ParseError(error.message);
  }
}

export { peg$parse as parseQuery };
`;

// Write the TypeScript file
fs.writeFileSync(outputPath, tsContent);

console.log(`Parser generated successfully at ${outputPath}`);
