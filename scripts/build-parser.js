#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const peggy = require('peggy');

const grammarPath = path.join(__dirname, '../src/query/grammar/query.pegjs');
const outputPath = path.join(__dirname, '../src/query/generated-parser.ts');

// Read the grammar file
const grammar = fs.readFileSync(grammarPath, 'utf8');

// Generate the parser
const parser = peggy.generate(grammar, {
  output: 'source',
  format: 'es',
  trace: false
});

// Remove the default exports from the generated parser to avoid conflicts
const cleanedParser = parser.replace(/^export \{[^}]+\};?\s*$/gm, '');

// Create TypeScript-compatible wrapper
const tsContent = `// Auto-generated parser from grammar.pegjs
// Do not edit this file directly - edit grammar.pegjs instead

/* eslint-disable */
// @ts-nocheck

import type { QueryNode } from './ast';

export class ParseError extends Error {
  public location?: {
    start: { line: number; column: number };
    end: { line: number; column: number };
  };

  constructor(message: string, location?: any) {
    super(message);
    this.name = 'ParseError';
    this.location = location;
  }
}

// Generated parser code (JavaScript)
${cleanedParser}

// TypeScript-compatible export wrapper
export function parse(input: string): QueryNode {
  try {
    const result = (peg$parse as any)(input, {});
    return result as QueryNode;
  } catch (error: any) {
    if (error.location) {
      throw new ParseError(
        \`Parse error at line \${error.location.start.line}, column \${error.location.start.column}: \${error.message}\`,
        error.location
      );
    }
    throw new ParseError(error.message || 'Unknown parse error');
  }
}

// Export internal functions for compatibility
export { peg$SyntaxError as SyntaxError };
`;

// Write the TypeScript file
fs.writeFileSync(outputPath, tsContent);

console.log(`Parser generated successfully at ${outputPath}`);
